<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>knowl.databaseAPI API documentation</title>
<meta name="description" content="@author: Radoslav Škoviera …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>knowl.databaseAPI</code></h1>
</header>
<section id="section-intro">
<p>@author: Radoslav Škoviera</p>
<p>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at <a href="http://mozilla.org/MPL/2.0/.">http://mozilla.org/MPL/2.0/.</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
@author: Radoslav Škoviera

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at http://mozilla.org/MPL/2.0/.
&#34;&#34;&#34;

from knowl import OntologyDatabase, DBConfig
from rdflib import URIRef, BNode, Literal
from rdflib.term import Identifier
from rdflib.namespace import Namespace, RDF, RDFS, OWL, FOAF
from collections import defaultdict
from collections.abc import Iterable
from itertools import chain
from rdflib.extras.infixowl import classOrIdentifier
import re


class OntologyAPI(OntologyDatabase):

    __databaseDict = {}

    def __new__(cls, config=None, *args, **kwargs):
        &#34;&#34;&#34;Returns an ontology database. The ontologies are identified by the uniqueID
        generated by the DBConfig object. This ID depends on the specific database server,
        database and the ontology (identified by ontology IRI). In order for this to work,
        the access credentials also has to be specified.

        Parameters
        ----------
        config : DBConfig or str
            [description]

        Returns
        -------
        OntologyDatabase
        &#34;&#34;&#34;
        config = DBConfig.factory(config)  # factory enables config specification in several formats, this line unifies them.
        id = config.uniqueID  # get the unique ID for the specific database+ontology
        if id in cls.__databaseDict:  # if ontology was already initialized in this program session, retrieve its reference
            db = cls.__databaseDict[id]
        else:  # otherwise create new ontology connection
            # db = OntologyAPI(config=config)
            db = super().__new__(cls)
            cls.__databaseDict[id] = db
        return db

    def __init__(self, config=None):
        super().__init__(config=config, create=True)
        self.setup()
        self.__objects = {}
        self.__nss = {ns[0]: Namespace(ns[1]) for ns in self._graph.namespaces()}

        self.__baseNamespace = self.namespaces[&#34;base&#34;]

    @property
    def namespaces(self):
        &#34;&#34;&#34;Returns a dictionary of namespaces binded to the database
        &#34;&#34;&#34;
        return self.__nss

    @property
    def baseNS(self):
        return self.__baseNamespace

    def getProperty(self, property):
        # TODO
        pass

    def existEntity(self, reference, anyRecord: bool = False):
        &#34;&#34;&#34;Checks if the entity corresponding to the reference exists in the ontology.

        Parameters
        ----------
        reference : RDF.term
            reference to the entity
        anyRecord : bool, optional
            If set to True, will search for any entry referencing the object. If set to False,
            existence of the entity&#39;s type is required (searched for). By default False

        Returns
        -------
        bool
            Whether the specified entity exists within the database
        &#34;&#34;&#34;
        if anyRecord:
            predicate = None
        else:
            predicate = RDF.type
        return (reference, predicate, None) in self._graph

    def getEntity(self, reference, makeIfDoesNotExist: bool = False):
        &#34;&#34;&#34;Returns a proxy to an entity in the ontology.
        If the object corresponding to the reference already exists in the database then simply the reference
        is returned. If it does not exist, it will be created.

        Parameters
        ----------
        reference : Identifier
            [description]

        makeIfDoesNotExist : bool
            If set to True, a blank entity with the specified reference will be created and returned.
            I.e., an entity will be created even if one does not exist within the database.

        Returns
        -------
        OntoEntity
            A proxy for the entity in the ontology.
        &#34;&#34;&#34;
        # create empty object as a default return value if no object exist and create is False
        obj = None
        # make sure reference is a valid identifier
        if isinstance(reference, str):
            reference = URIRef(reference)
        # create reference string
        refString = reference.n3()
        # check if the referenced objects is remembered by the API
        if refString in self.__objects:
            obj = self.__objects[refString]
            # check if the referenced object still exists within the DB
            if not obj.exists:
                # if the object is no longer in DB, remove it from the dict and return None
                del self.__objects[refString]
                return None
        else:
            # check if the reference exist within the database
            if self.existEntity(reference):
                # TODO: obj =  # make new object but don&#39;t write into DB (it&#39;s already there)
                pass
            elif makeIfDoesNotExist:
                obj = self.makeEntity(reference)
        return obj

    def makeEntity(self, reference, attributes: dict = {}, **kwargs):
        &#34;&#34;&#34;Creates and object in this ontology
        Objects should only be created using this function (i.e. not by instantiating the OntoObject class directly).
        The main reason for this is that the OntoObject does not existence of such object in the current ontology
        and thus duplicates could be produced.

        Parameters
        ----------
        reference : URIRef or similar
            URI reference of the object to be created. If the provided reference referres to a class a new object
            is instantiated instead of providing reference to an object already existing in the database.

        Returns
        -------
        OntoEntity
            A proxy for the entity in the ontology.
        &#34;&#34;&#34;
        refString = reference.n3()
        # merge the attributes
        attributes = {**attributes, **self.__expandPythonAttributes(kwargs)}
        # check if the referenced objects is remembered by the API
        obj = self.getEntity(reference, makeIfDoesNotExist=False)
        if obj is not None:
            # update the objects attributes according to the provided parameters
            obj[attributes.keys()] = attributes.values()
        else:
            # if not, check if it is a class
            if (reference, RDF.type, OWL.Class) in self:
                # if the reference is class, create a new object using that class
                obj = OntoEntity(self, **{**{RDF.type: reference}, **attributes})
            else:
                # This kind of entity creation assumes that the class/type of the entity is specified in the attributes!!!
                obj = OntoEntity(self, name=reference, **attributes)
            self.__objects[refString] = obj
        return obj

    def __getattr__(self, key):
        &#34;&#34;&#34;Properties that do not exist as a part of this class are returned as URI from the base namespace
        &#34;&#34;&#34;
        if key.startswith(&#34;_&#34;) or key in self.__dir__():
            return super().__getattribute__(key)
        else:
            # return self.baseNS[key]
            return ProxyReference(key, self.baseNS, self.makeEntity)

    def __expandPythonAttributes(self, pyattributes):
        # TODO: Translate python named attributes into URIRefs
        &#34;&#34;&#34;Calling a function with optional &#34;kwargs&#34; is only possible
        if the kwargs keys are simple expressions (e.g., type)
        and not complex expressions like for example calls to object
        methods or expressions containing control characters (e.g., #).
        Thus something like &#34;makeEntity(ref, RDF.type=OWL.Class) is not possible.
        The RDF.type results in invalid syntax. A workaround is  to call the function
        with a dictionary containing this definition but that is not elegant.
        The goals of this function is to allow call like makeEntity(ref, type=OWL.Class, subClassOf=BASE.SomeClass)
        and translate the keys from [&#34;type&#34;, &#34;subClassOf&#34;] into [RDF.type, OWL.subClassOf],
        thus allowing this simplified function call.

        Parameters
        ----------
        pyattributes : dict
            The input dictionary with keys in simple form that needs to be expanded.

        Returns
        -------
        dict
            A dictionary containing much the same values but the keys are expanded into URIRefs.
        &#34;&#34;&#34;
        self._graph.compute_qname
        return pyattributes

    def getEntsByClass(self, cls, typePredicate: URIRef = RDF.type):
        &#34;&#34;&#34;Returns a list of entities of the specified class or type.

        Parameters
        ----------
        cls : [str, URIRef]
            The identifier of the class to be searched for.

        typePredicate : URIRef, optional
            This paramaters can optionally by changed to modify the predicate
            denoting the &#34;entity is of class&#34; statement. Under normal circumstances,
            there shall be no need to actually change this, by default RDF.type.

        Returns
        -------
        list of OntoEntity
            A list of objects with the specified type.
        &#34;&#34;&#34;
        pass

    def isAncestorOf(self, alleged_ancestor, thing):
        # FIXME: there simply HAS TO BE a better way
        return classOrIdentifier(alleged_ancestor) in self.transitive_objects(classOrIdentifier(thing), RDFS.subClassOf)


# TODO: maybe more thought should be put into this
uriMatchingRegex = re.compile(r&#34;.+\/\w+\.\w+&#34;, re.IGNORECASE)


def isValidURI(ref):
    return uriMatchingRegex.search(ref) is not None


def castIntoProperURI(ref, baseNS):
    if not isValidURI(ref):
        ref = baseNS[ref]
    return ref


def castIntoValidTerm(val):
    if val is None:
        return BNode()
    elif not isinstance(val, (Identifier, Literal)):
        if isinstance(val, str) and isValidURI(val):
            val = URIRef(val)
        else:
            val = Literal(val)
    return val


class ProxyReference(URIRef):

    def __new__(cls, name, namespace, caller, *args, **kwargs):
        value = namespace[name]
        base = None
        return super().__new__(cls, value, base)

    def __init__(self, name, namespace, caller):
        super().__init__()
        self._ns = namespace
        self._caller = caller

    def __call__(self, **kwargs):
        return self._caller(self, {self._ns[k]: castIntoValidTerm(v) for k, v in kwargs.items()})


class ProxyAttribute():
    &#34;&#34;&#34;This object serves as proxy for OntoEntity&#39;s property.
    It is a &#34;hack&#34; to make namespace work in the dot notation.
    I.e., entity.Namespace.property
    &#34;&#34;&#34;

    def __init__(self, ns, caller):
        self._ns = ns
        self._caller = caller

    def __setattr__(self, key, value):
        if key.startswith(&#34;_&#34;):
            super().__setattr__(key, value)
        else:
            self._caller[self._ns[key]] = value

    def __getattr__(self, key):
        if key.startswith(&#34;_&#34;):
            super().__getattribute__(key)
        else:
            return self._caller[self._ns[key]]


class OntoProperty():
    &#34;&#34;&#34;Proxy for ontologic property/predicate.
    Contains various properties for quick access - i.e. properties like &#34;functional&#34;
    can be queried from this proxy instead of the database, which should provide
    some speedup. Only works if properties are queried multiple times (the first time
    everything has to be loaded from the database).
    Also, provides convenience access using the OOP approach.

    TODO
    &#34;&#34;&#34;

    def __init__(self, onto: OntologyAPI, **kwargs):
        self.__onto = onto


class OntoEntity():
    &#34;&#34;&#34;Ontology entity (subject or object)
    This class provides a convenience access to the entities inside the ontologic database.
    Creating this object directly is not recommended. Use OntologyAPI.makeObject or similar function instead.

    # TODO: check whether an object should be a VALUE or not (i.e. update only once)
    &#34;&#34;&#34;

    def __init__(self, onto: OntologyAPI, **kwargs):
        # kwargs = defaultdict(lambda: None, kwargs)

        self.__onto = onto
        self.__baseNS = self.__onto.baseNS

        if &#34;name&#34; in kwargs:
            self.__node = BNode(kwargs[&#34;name&#34;])
            del kwargs[&#34;name&#34;]
        else:
            self.__node = BNode()

        if len(kwargs) &gt; 0:
            self[kwargs.keys()] = kwargs.values()

    def __repr__(self):
        return self.node

    def __str__(self):
        return self.node.toPython()

    def n3(self, namespace_manager=None):
        return self.node.n3(namespace_manager=namespace_manager)

    def __getattr__(self, key):
        &#34;&#34;&#34;Working examples:

        entity.Namespace.property
        entity.property; where property is a valid predicate in the ontology
        &#34;&#34;&#34;
        if key.startswith(&#34;_&#34;) or key in self.__dir__():
            return super().__getattribute__(key)
        elif key.lower() in self.__onto.namespaces:
            return ProxyAttribute(self.__onto.namespaces[key.lower()], self)
        else:
            q = (self.node, castIntoProperURI(key, self.__baseNS), None)
            ans = [a[2] for a in self.__onto.triples(q)]
            if len(ans) == 1:
                return ans[0]
            else:
                return ans

    def __setattr__(self, key, value):
        &#34;&#34;&#34;Working examples

        entity.Namespace.property = value
        entity.property = value; where property is a valid predicate in the ontology

        &#34;&#34;&#34;
        if key.startswith(&#34;_&#34;) or key in self.__dir__():
            super().__setattr__(key, value)
        else:
            if key.lower() in self.__onto.namespaces:
                return ProxyAttribute(self.__onto.namespaces[key.lower()], self)
            else:
                value = castIntoValidTerm(value)
                # TODO: take care of &#34;set&#34; values!
                q = (self.node, castIntoProperURI(key, self.__baseNS), value)
                self.__onto.set(q)

    def __setitem__(self, keys, values):
        &#34;&#34;&#34;Working examples

        entity[Namespace.property] = value
        entity[property] = value; where property is a valid predicate in the ontology
        entity[Namespace.property1; OtherNamespace.property2] = [value1, value2]; works for any number of property/value pairs
        entity[property1, property2] = [value1, value2]; where property is a valid predicate in the ontology; works for any number of property/value pairs

        Values can be provided as Identifiers or as Python variables (these will be converted into Literals).
        &#34;&#34;&#34;
        # check if multiple values were provided
        if isinstance(keys, Iterable) and not (isinstance(keys, Identifier) or isinstance(keys, str)):
            # form multiple triples and send them at once to the database
            for k in keys:
                # Remove previous entries with the same property, i.e. perform an &#34;update&#34; - maybe change this in the future
                self.__onto.remove((self.node, k, None))
            self.__onto.addN([(self.node, castIntoProperURI(k, self.__baseNS), castIntoValidTerm(v)) for (k, v) in zip(keys, values)])
        else:
            # is only a single field is to be updated, use the setattr method
            self.__setattr__(keys, values)

    def __getitem__(self, keys):
        &#34;&#34;&#34;Working examples

        entity[Namespace.property]
        entity[property]; where property is a valid predicate in the ontology
        entity[Namespace.property1; OtherNamespace.property2]; works for any number of properties
        entity[property1, property2]; where property is a valid predicate in the ontology; works for any number of properties

        The later two examples will return a list of values.
        &#34;&#34;&#34;
        if isinstance(keys, Iterable) and not (isinstance(keys, Identifier) or isinstance(keys, str)):
            # form multiple triples and send them at once to the database
            ans = list(chain(*[self.__onto.objects(self.node, castIntoProperURI(k, self.__baseNS)) for k in keys]))
            return ans
        else:
            # is only a single field is to be updated, use the setattr method
            return self.__getattr__(keys)

    @property
    def list(self):
        return list(self.__onto.triples((self.node, None, None)))

    @property
    def properties(self):
        return list(self.__onto.predicate_objects(self.node))

    @property
    def usage(self):
        return list(self.__onto.subject_predicates(self.node))

    @property
    def type(self):
        ans = list(self.__onto.objects(subject=self.node, predicate=RDF.type))
        return ans[0] if len(ans) == 1 else ans

    @property
    def localType(self):
        &#34;&#34;&#34;Returns local type of this entity.
        That is, only the last part of the type URI (e.g., &#34;Cube&#34;)
        &#34;&#34;&#34;
        globalType = self.type
        if isinstance(globalType, list):
            localType = [self.__onto.compute_qname(t)[2] for t in globalType]
        else:
            _, _, localType = self.__onto.compute_qname(globalType)
        return localType

    # def _set_type(self, kind):
    # TODO:
    #     if not kind:
    #         return
    #     if isinstance(kind, (Individual, Identifier)):
    #         self.graph.add(
    #             (self.identifier, RDF.type, classOrIdentifier(kind)))
    #     else:
    #         for c in kind:
    #             assert isinstance(c, (Individual, Identifier))
    #             self.graph.add(
    #                 (self.identifier, RDF.type, classOrIdentifier(c)))

    def __delattr__(self, name):
        &#34;&#34;&#34;Deletes the specified property of this entity from the database
        &#34;&#34;&#34;
        if name.startswith(&#34;_&#34;) or name in self.__dir__():
            return super().__delattr__(name)
        else:
            return self.__onto.remove((self.node, name, None))

    def destroy(self):
        &#34;&#34;&#34;Removes any entries containing this entity. Removes entries containing this entity
        as subjects and objects alike.
        &#34;&#34;&#34;
        # TODO: more careful removal
        self.__onto.remove((self.node, None, None))
        self.__onto.remove((None, None, self.node))

    @property
    def exists(self):
        &#34;&#34;&#34;Returns whether this entity is still contained in the database.
        More specifically, whether there are any entries containing this entity
        as subject.

        Returns
        -------
        bool
            Whether the entity is in the ontology
        &#34;&#34;&#34;
        return (self.node, None, None) in self.__onto

    @property
    def node(self):
        &#34;&#34;&#34;BNode or other Identifier identifying this entity in the database

        Returns
        -------
        Identifier
        &#34;&#34;&#34;
        return self.__node</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="knowl.databaseAPI.castIntoProperURI"><code class="name flex">
<span>def <span class="ident">castIntoProperURI</span></span>(<span>ref, baseNS)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def castIntoProperURI(ref, baseNS):
    if not isValidURI(ref):
        ref = baseNS[ref]
    return ref</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.castIntoValidTerm"><code class="name flex">
<span>def <span class="ident">castIntoValidTerm</span></span>(<span>val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def castIntoValidTerm(val):
    if val is None:
        return BNode()
    elif not isinstance(val, (Identifier, Literal)):
        if isinstance(val, str) and isValidURI(val):
            val = URIRef(val)
        else:
            val = Literal(val)
    return val</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.isValidURI"><code class="name flex">
<span>def <span class="ident">isValidURI</span></span>(<span>ref)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isValidURI(ref):
    return uriMatchingRegex.search(ref) is not None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="knowl.databaseAPI.OntoEntity"><code class="flex name class">
<span>class <span class="ident">OntoEntity</span></span>
<span>(</span><span>onto: <a title="knowl.databaseAPI.OntologyAPI" href="#knowl.databaseAPI.OntologyAPI">OntologyAPI</a>, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Ontology entity (subject or object)
This class provides a convenience access to the entities inside the ontologic database.
Creating this object directly is not recommended. Use OntologyAPI.makeObject or similar function instead.</p>
<h1 id="todo-check-whether-an-object-should-be-a-value-or-not-ie-update-only-once">TODO: check whether an object should be a VALUE or not (i.e. update only once)</h1></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OntoEntity():
    &#34;&#34;&#34;Ontology entity (subject or object)
    This class provides a convenience access to the entities inside the ontologic database.
    Creating this object directly is not recommended. Use OntologyAPI.makeObject or similar function instead.

    # TODO: check whether an object should be a VALUE or not (i.e. update only once)
    &#34;&#34;&#34;

    def __init__(self, onto: OntologyAPI, **kwargs):
        # kwargs = defaultdict(lambda: None, kwargs)

        self.__onto = onto
        self.__baseNS = self.__onto.baseNS

        if &#34;name&#34; in kwargs:
            self.__node = BNode(kwargs[&#34;name&#34;])
            del kwargs[&#34;name&#34;]
        else:
            self.__node = BNode()

        if len(kwargs) &gt; 0:
            self[kwargs.keys()] = kwargs.values()

    def __repr__(self):
        return self.node

    def __str__(self):
        return self.node.toPython()

    def n3(self, namespace_manager=None):
        return self.node.n3(namespace_manager=namespace_manager)

    def __getattr__(self, key):
        &#34;&#34;&#34;Working examples:

        entity.Namespace.property
        entity.property; where property is a valid predicate in the ontology
        &#34;&#34;&#34;
        if key.startswith(&#34;_&#34;) or key in self.__dir__():
            return super().__getattribute__(key)
        elif key.lower() in self.__onto.namespaces:
            return ProxyAttribute(self.__onto.namespaces[key.lower()], self)
        else:
            q = (self.node, castIntoProperURI(key, self.__baseNS), None)
            ans = [a[2] for a in self.__onto.triples(q)]
            if len(ans) == 1:
                return ans[0]
            else:
                return ans

    def __setattr__(self, key, value):
        &#34;&#34;&#34;Working examples

        entity.Namespace.property = value
        entity.property = value; where property is a valid predicate in the ontology

        &#34;&#34;&#34;
        if key.startswith(&#34;_&#34;) or key in self.__dir__():
            super().__setattr__(key, value)
        else:
            if key.lower() in self.__onto.namespaces:
                return ProxyAttribute(self.__onto.namespaces[key.lower()], self)
            else:
                value = castIntoValidTerm(value)
                # TODO: take care of &#34;set&#34; values!
                q = (self.node, castIntoProperURI(key, self.__baseNS), value)
                self.__onto.set(q)

    def __setitem__(self, keys, values):
        &#34;&#34;&#34;Working examples

        entity[Namespace.property] = value
        entity[property] = value; where property is a valid predicate in the ontology
        entity[Namespace.property1; OtherNamespace.property2] = [value1, value2]; works for any number of property/value pairs
        entity[property1, property2] = [value1, value2]; where property is a valid predicate in the ontology; works for any number of property/value pairs

        Values can be provided as Identifiers or as Python variables (these will be converted into Literals).
        &#34;&#34;&#34;
        # check if multiple values were provided
        if isinstance(keys, Iterable) and not (isinstance(keys, Identifier) or isinstance(keys, str)):
            # form multiple triples and send them at once to the database
            for k in keys:
                # Remove previous entries with the same property, i.e. perform an &#34;update&#34; - maybe change this in the future
                self.__onto.remove((self.node, k, None))
            self.__onto.addN([(self.node, castIntoProperURI(k, self.__baseNS), castIntoValidTerm(v)) for (k, v) in zip(keys, values)])
        else:
            # is only a single field is to be updated, use the setattr method
            self.__setattr__(keys, values)

    def __getitem__(self, keys):
        &#34;&#34;&#34;Working examples

        entity[Namespace.property]
        entity[property]; where property is a valid predicate in the ontology
        entity[Namespace.property1; OtherNamespace.property2]; works for any number of properties
        entity[property1, property2]; where property is a valid predicate in the ontology; works for any number of properties

        The later two examples will return a list of values.
        &#34;&#34;&#34;
        if isinstance(keys, Iterable) and not (isinstance(keys, Identifier) or isinstance(keys, str)):
            # form multiple triples and send them at once to the database
            ans = list(chain(*[self.__onto.objects(self.node, castIntoProperURI(k, self.__baseNS)) for k in keys]))
            return ans
        else:
            # is only a single field is to be updated, use the setattr method
            return self.__getattr__(keys)

    @property
    def list(self):
        return list(self.__onto.triples((self.node, None, None)))

    @property
    def properties(self):
        return list(self.__onto.predicate_objects(self.node))

    @property
    def usage(self):
        return list(self.__onto.subject_predicates(self.node))

    @property
    def type(self):
        ans = list(self.__onto.objects(subject=self.node, predicate=RDF.type))
        return ans[0] if len(ans) == 1 else ans

    @property
    def localType(self):
        &#34;&#34;&#34;Returns local type of this entity.
        That is, only the last part of the type URI (e.g., &#34;Cube&#34;)
        &#34;&#34;&#34;
        globalType = self.type
        if isinstance(globalType, list):
            localType = [self.__onto.compute_qname(t)[2] for t in globalType]
        else:
            _, _, localType = self.__onto.compute_qname(globalType)
        return localType

    # def _set_type(self, kind):
    # TODO:
    #     if not kind:
    #         return
    #     if isinstance(kind, (Individual, Identifier)):
    #         self.graph.add(
    #             (self.identifier, RDF.type, classOrIdentifier(kind)))
    #     else:
    #         for c in kind:
    #             assert isinstance(c, (Individual, Identifier))
    #             self.graph.add(
    #                 (self.identifier, RDF.type, classOrIdentifier(c)))

    def __delattr__(self, name):
        &#34;&#34;&#34;Deletes the specified property of this entity from the database
        &#34;&#34;&#34;
        if name.startswith(&#34;_&#34;) or name in self.__dir__():
            return super().__delattr__(name)
        else:
            return self.__onto.remove((self.node, name, None))

    def destroy(self):
        &#34;&#34;&#34;Removes any entries containing this entity. Removes entries containing this entity
        as subjects and objects alike.
        &#34;&#34;&#34;
        # TODO: more careful removal
        self.__onto.remove((self.node, None, None))
        self.__onto.remove((None, None, self.node))

    @property
    def exists(self):
        &#34;&#34;&#34;Returns whether this entity is still contained in the database.
        More specifically, whether there are any entries containing this entity
        as subject.

        Returns
        -------
        bool
            Whether the entity is in the ontology
        &#34;&#34;&#34;
        return (self.node, None, None) in self.__onto

    @property
    def node(self):
        &#34;&#34;&#34;BNode or other Identifier identifying this entity in the database

        Returns
        -------
        Identifier
        &#34;&#34;&#34;
        return self.__node</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="knowl.databaseAPI.OntoEntity.exists"><code class="name">var <span class="ident">exists</span></code></dt>
<dd>
<div class="desc"><p>Returns whether this entity is still contained in the database.
More specifically, whether there are any entries containing this entity
as subject.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the entity is in the ontology</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exists(self):
    &#34;&#34;&#34;Returns whether this entity is still contained in the database.
    More specifically, whether there are any entries containing this entity
    as subject.

    Returns
    -------
    bool
        Whether the entity is in the ontology
    &#34;&#34;&#34;
    return (self.node, None, None) in self.__onto</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.OntoEntity.list"><code class="name">var <span class="ident">list</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def list(self):
    return list(self.__onto.triples((self.node, None, None)))</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.OntoEntity.localType"><code class="name">var <span class="ident">localType</span></code></dt>
<dd>
<div class="desc"><p>Returns local type of this entity.
That is, only the last part of the type URI (e.g., "Cube")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def localType(self):
    &#34;&#34;&#34;Returns local type of this entity.
    That is, only the last part of the type URI (e.g., &#34;Cube&#34;)
    &#34;&#34;&#34;
    globalType = self.type
    if isinstance(globalType, list):
        localType = [self.__onto.compute_qname(t)[2] for t in globalType]
    else:
        _, _, localType = self.__onto.compute_qname(globalType)
    return localType</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.OntoEntity.node"><code class="name">var <span class="ident">node</span></code></dt>
<dd>
<div class="desc"><p>BNode or other Identifier identifying this entity in the database</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Identifier</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def node(self):
    &#34;&#34;&#34;BNode or other Identifier identifying this entity in the database

    Returns
    -------
    Identifier
    &#34;&#34;&#34;
    return self.__node</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.OntoEntity.properties"><code class="name">var <span class="ident">properties</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def properties(self):
    return list(self.__onto.predicate_objects(self.node))</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.OntoEntity.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self):
    ans = list(self.__onto.objects(subject=self.node, predicate=RDF.type))
    return ans[0] if len(ans) == 1 else ans</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.OntoEntity.usage"><code class="name">var <span class="ident">usage</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def usage(self):
    return list(self.__onto.subject_predicates(self.node))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="knowl.databaseAPI.OntoEntity.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes any entries containing this entity. Removes entries containing this entity
as subjects and objects alike.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy(self):
    &#34;&#34;&#34;Removes any entries containing this entity. Removes entries containing this entity
    as subjects and objects alike.
    &#34;&#34;&#34;
    # TODO: more careful removal
    self.__onto.remove((self.node, None, None))
    self.__onto.remove((None, None, self.node))</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.OntoEntity.n3"><code class="name flex">
<span>def <span class="ident">n3</span></span>(<span>self, namespace_manager=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def n3(self, namespace_manager=None):
    return self.node.n3(namespace_manager=namespace_manager)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="knowl.databaseAPI.OntoProperty"><code class="flex name class">
<span>class <span class="ident">OntoProperty</span></span>
<span>(</span><span>onto: <a title="knowl.databaseAPI.OntologyAPI" href="#knowl.databaseAPI.OntologyAPI">OntologyAPI</a>, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Proxy for ontologic property/predicate.
Contains various properties for quick access - i.e. properties like "functional"
can be queried from this proxy instead of the database, which should provide
some speedup. Only works if properties are queried multiple times (the first time
everything has to be loaded from the database).
Also, provides convenience access using the OOP approach.</p>
<p>TODO</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OntoProperty():
    &#34;&#34;&#34;Proxy for ontologic property/predicate.
    Contains various properties for quick access - i.e. properties like &#34;functional&#34;
    can be queried from this proxy instead of the database, which should provide
    some speedup. Only works if properties are queried multiple times (the first time
    everything has to be loaded from the database).
    Also, provides convenience access using the OOP approach.

    TODO
    &#34;&#34;&#34;

    def __init__(self, onto: OntologyAPI, **kwargs):
        self.__onto = onto</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.OntologyAPI"><code class="flex name class">
<span>class <span class="ident">OntologyAPI</span></span>
<span>(</span><span>config=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A front-end of an ontology database. This class provides "safe" access to most of the standard
operations provided by the rdflib.Graph class. The "safeness" of the methods lies in catching
exceptions and reconnecting shall the connection to the database "die" for whatever reason.
Additionally, this class implements the SQLAlchemy store for the triples</p>
<p>Create ontology database API with SQLAlchemy store.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>[str, knowl.DBConfig]</code>, optional</dt>
<dd>The path to a configuration file or the configuration object. By default None,
which results in a configuration with default parameters (see knowl.DBConfig).</dd>
<dt><strong><code>create</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not the tables for the ontology (triplestore) should be initalized.
Set to True if you are creating a new database, by default None.
As per SQLAlchemy documentation, the creation operation is idempotent. Thus,
could be left at True, unless you specifically do not want to create a new database
if one does not exist.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OntologyAPI(OntologyDatabase):

    __databaseDict = {}

    def __new__(cls, config=None, *args, **kwargs):
        &#34;&#34;&#34;Returns an ontology database. The ontologies are identified by the uniqueID
        generated by the DBConfig object. This ID depends on the specific database server,
        database and the ontology (identified by ontology IRI). In order for this to work,
        the access credentials also has to be specified.

        Parameters
        ----------
        config : DBConfig or str
            [description]

        Returns
        -------
        OntologyDatabase
        &#34;&#34;&#34;
        config = DBConfig.factory(config)  # factory enables config specification in several formats, this line unifies them.
        id = config.uniqueID  # get the unique ID for the specific database+ontology
        if id in cls.__databaseDict:  # if ontology was already initialized in this program session, retrieve its reference
            db = cls.__databaseDict[id]
        else:  # otherwise create new ontology connection
            # db = OntologyAPI(config=config)
            db = super().__new__(cls)
            cls.__databaseDict[id] = db
        return db

    def __init__(self, config=None):
        super().__init__(config=config, create=True)
        self.setup()
        self.__objects = {}
        self.__nss = {ns[0]: Namespace(ns[1]) for ns in self._graph.namespaces()}

        self.__baseNamespace = self.namespaces[&#34;base&#34;]

    @property
    def namespaces(self):
        &#34;&#34;&#34;Returns a dictionary of namespaces binded to the database
        &#34;&#34;&#34;
        return self.__nss

    @property
    def baseNS(self):
        return self.__baseNamespace

    def getProperty(self, property):
        # TODO
        pass

    def existEntity(self, reference, anyRecord: bool = False):
        &#34;&#34;&#34;Checks if the entity corresponding to the reference exists in the ontology.

        Parameters
        ----------
        reference : RDF.term
            reference to the entity
        anyRecord : bool, optional
            If set to True, will search for any entry referencing the object. If set to False,
            existence of the entity&#39;s type is required (searched for). By default False

        Returns
        -------
        bool
            Whether the specified entity exists within the database
        &#34;&#34;&#34;
        if anyRecord:
            predicate = None
        else:
            predicate = RDF.type
        return (reference, predicate, None) in self._graph

    def getEntity(self, reference, makeIfDoesNotExist: bool = False):
        &#34;&#34;&#34;Returns a proxy to an entity in the ontology.
        If the object corresponding to the reference already exists in the database then simply the reference
        is returned. If it does not exist, it will be created.

        Parameters
        ----------
        reference : Identifier
            [description]

        makeIfDoesNotExist : bool
            If set to True, a blank entity with the specified reference will be created and returned.
            I.e., an entity will be created even if one does not exist within the database.

        Returns
        -------
        OntoEntity
            A proxy for the entity in the ontology.
        &#34;&#34;&#34;
        # create empty object as a default return value if no object exist and create is False
        obj = None
        # make sure reference is a valid identifier
        if isinstance(reference, str):
            reference = URIRef(reference)
        # create reference string
        refString = reference.n3()
        # check if the referenced objects is remembered by the API
        if refString in self.__objects:
            obj = self.__objects[refString]
            # check if the referenced object still exists within the DB
            if not obj.exists:
                # if the object is no longer in DB, remove it from the dict and return None
                del self.__objects[refString]
                return None
        else:
            # check if the reference exist within the database
            if self.existEntity(reference):
                # TODO: obj =  # make new object but don&#39;t write into DB (it&#39;s already there)
                pass
            elif makeIfDoesNotExist:
                obj = self.makeEntity(reference)
        return obj

    def makeEntity(self, reference, attributes: dict = {}, **kwargs):
        &#34;&#34;&#34;Creates and object in this ontology
        Objects should only be created using this function (i.e. not by instantiating the OntoObject class directly).
        The main reason for this is that the OntoObject does not existence of such object in the current ontology
        and thus duplicates could be produced.

        Parameters
        ----------
        reference : URIRef or similar
            URI reference of the object to be created. If the provided reference referres to a class a new object
            is instantiated instead of providing reference to an object already existing in the database.

        Returns
        -------
        OntoEntity
            A proxy for the entity in the ontology.
        &#34;&#34;&#34;
        refString = reference.n3()
        # merge the attributes
        attributes = {**attributes, **self.__expandPythonAttributes(kwargs)}
        # check if the referenced objects is remembered by the API
        obj = self.getEntity(reference, makeIfDoesNotExist=False)
        if obj is not None:
            # update the objects attributes according to the provided parameters
            obj[attributes.keys()] = attributes.values()
        else:
            # if not, check if it is a class
            if (reference, RDF.type, OWL.Class) in self:
                # if the reference is class, create a new object using that class
                obj = OntoEntity(self, **{**{RDF.type: reference}, **attributes})
            else:
                # This kind of entity creation assumes that the class/type of the entity is specified in the attributes!!!
                obj = OntoEntity(self, name=reference, **attributes)
            self.__objects[refString] = obj
        return obj

    def __getattr__(self, key):
        &#34;&#34;&#34;Properties that do not exist as a part of this class are returned as URI from the base namespace
        &#34;&#34;&#34;
        if key.startswith(&#34;_&#34;) or key in self.__dir__():
            return super().__getattribute__(key)
        else:
            # return self.baseNS[key]
            return ProxyReference(key, self.baseNS, self.makeEntity)

    def __expandPythonAttributes(self, pyattributes):
        # TODO: Translate python named attributes into URIRefs
        &#34;&#34;&#34;Calling a function with optional &#34;kwargs&#34; is only possible
        if the kwargs keys are simple expressions (e.g., type)
        and not complex expressions like for example calls to object
        methods or expressions containing control characters (e.g., #).
        Thus something like &#34;makeEntity(ref, RDF.type=OWL.Class) is not possible.
        The RDF.type results in invalid syntax. A workaround is  to call the function
        with a dictionary containing this definition but that is not elegant.
        The goals of this function is to allow call like makeEntity(ref, type=OWL.Class, subClassOf=BASE.SomeClass)
        and translate the keys from [&#34;type&#34;, &#34;subClassOf&#34;] into [RDF.type, OWL.subClassOf],
        thus allowing this simplified function call.

        Parameters
        ----------
        pyattributes : dict
            The input dictionary with keys in simple form that needs to be expanded.

        Returns
        -------
        dict
            A dictionary containing much the same values but the keys are expanded into URIRefs.
        &#34;&#34;&#34;
        self._graph.compute_qname
        return pyattributes

    def getEntsByClass(self, cls, typePredicate: URIRef = RDF.type):
        &#34;&#34;&#34;Returns a list of entities of the specified class or type.

        Parameters
        ----------
        cls : [str, URIRef]
            The identifier of the class to be searched for.

        typePredicate : URIRef, optional
            This paramaters can optionally by changed to modify the predicate
            denoting the &#34;entity is of class&#34; statement. Under normal circumstances,
            there shall be no need to actually change this, by default RDF.type.

        Returns
        -------
        list of OntoEntity
            A list of objects with the specified type.
        &#34;&#34;&#34;
        pass

    def isAncestorOf(self, alleged_ancestor, thing):
        # FIXME: there simply HAS TO BE a better way
        return classOrIdentifier(alleged_ancestor) in self.transitive_objects(classOrIdentifier(thing), RDFS.subClassOf)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="knowl.database.OntologyDatabase" href="database.html#knowl.database.OntologyDatabase">OntologyDatabase</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="knowl.databaseAPI.OntologyAPI.baseNS"><code class="name">var <span class="ident">baseNS</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def baseNS(self):
    return self.__baseNamespace</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.OntologyAPI.namespaces"><code class="name">var <span class="ident">namespaces</span></code></dt>
<dd>
<div class="desc"><p>Returns a dictionary of namespaces binded to the database</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def namespaces(self):
    &#34;&#34;&#34;Returns a dictionary of namespaces binded to the database
    &#34;&#34;&#34;
    return self.__nss</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="knowl.databaseAPI.OntologyAPI.existEntity"><code class="name flex">
<span>def <span class="ident">existEntity</span></span>(<span>self, reference, anyRecord: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the entity corresponding to the reference exists in the ontology.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reference</code></strong> :&ensp;<code>RDF.term</code></dt>
<dd>reference to the entity</dd>
<dt><strong><code>anyRecord</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If set to True, will search for any entry referencing the object. If set to False,
existence of the entity's type is required (searched for). By default False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>Whether the specified entity exists within the database</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def existEntity(self, reference, anyRecord: bool = False):
    &#34;&#34;&#34;Checks if the entity corresponding to the reference exists in the ontology.

    Parameters
    ----------
    reference : RDF.term
        reference to the entity
    anyRecord : bool, optional
        If set to True, will search for any entry referencing the object. If set to False,
        existence of the entity&#39;s type is required (searched for). By default False

    Returns
    -------
    bool
        Whether the specified entity exists within the database
    &#34;&#34;&#34;
    if anyRecord:
        predicate = None
    else:
        predicate = RDF.type
    return (reference, predicate, None) in self._graph</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.OntologyAPI.getEntity"><code class="name flex">
<span>def <span class="ident">getEntity</span></span>(<span>self, reference, makeIfDoesNotExist: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a proxy to an entity in the ontology.
If the object corresponding to the reference already exists in the database then simply the reference
is returned. If it does not exist, it will be created.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reference</code></strong> :&ensp;<code>Identifier</code></dt>
<dd>[description]</dd>
<dt><strong><code>makeIfDoesNotExist</code></strong> :&ensp;<code>bool</code></dt>
<dd>If set to True, a blank entity with the specified reference will be created and returned.
I.e., an entity will be created even if one does not exist within the database.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="knowl.databaseAPI.OntoEntity" href="#knowl.databaseAPI.OntoEntity">OntoEntity</a></code></dt>
<dd>A proxy for the entity in the ontology.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getEntity(self, reference, makeIfDoesNotExist: bool = False):
    &#34;&#34;&#34;Returns a proxy to an entity in the ontology.
    If the object corresponding to the reference already exists in the database then simply the reference
    is returned. If it does not exist, it will be created.

    Parameters
    ----------
    reference : Identifier
        [description]

    makeIfDoesNotExist : bool
        If set to True, a blank entity with the specified reference will be created and returned.
        I.e., an entity will be created even if one does not exist within the database.

    Returns
    -------
    OntoEntity
        A proxy for the entity in the ontology.
    &#34;&#34;&#34;
    # create empty object as a default return value if no object exist and create is False
    obj = None
    # make sure reference is a valid identifier
    if isinstance(reference, str):
        reference = URIRef(reference)
    # create reference string
    refString = reference.n3()
    # check if the referenced objects is remembered by the API
    if refString in self.__objects:
        obj = self.__objects[refString]
        # check if the referenced object still exists within the DB
        if not obj.exists:
            # if the object is no longer in DB, remove it from the dict and return None
            del self.__objects[refString]
            return None
    else:
        # check if the reference exist within the database
        if self.existEntity(reference):
            # TODO: obj =  # make new object but don&#39;t write into DB (it&#39;s already there)
            pass
        elif makeIfDoesNotExist:
            obj = self.makeEntity(reference)
    return obj</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.OntologyAPI.getEntsByClass"><code class="name flex">
<span>def <span class="ident">getEntsByClass</span></span>(<span>self, cls, typePredicate: rdflib.term.URIRef = rdflib.term.URIRef('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'))</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of entities of the specified class or type.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cls</code></strong> :&ensp;<code>[str, URIRef]</code></dt>
<dd>The identifier of the class to be searched for.</dd>
<dt><strong><code>typePredicate</code></strong> :&ensp;<code>URIRef</code>, optional</dt>
<dd>This paramaters can optionally by changed to modify the predicate
denoting the "entity is of class" statement. Under normal circumstances,
there shall be no need to actually change this, by default RDF.type.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code><a title="knowl.databaseAPI.OntoEntity" href="#knowl.databaseAPI.OntoEntity">OntoEntity</a></code></dt>
<dd>A list of objects with the specified type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getEntsByClass(self, cls, typePredicate: URIRef = RDF.type):
    &#34;&#34;&#34;Returns a list of entities of the specified class or type.

    Parameters
    ----------
    cls : [str, URIRef]
        The identifier of the class to be searched for.

    typePredicate : URIRef, optional
        This paramaters can optionally by changed to modify the predicate
        denoting the &#34;entity is of class&#34; statement. Under normal circumstances,
        there shall be no need to actually change this, by default RDF.type.

    Returns
    -------
    list of OntoEntity
        A list of objects with the specified type.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.OntologyAPI.getProperty"><code class="name flex">
<span>def <span class="ident">getProperty</span></span>(<span>self, property)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getProperty(self, property):
    # TODO
    pass</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.OntologyAPI.isAncestorOf"><code class="name flex">
<span>def <span class="ident">isAncestorOf</span></span>(<span>self, alleged_ancestor, thing)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isAncestorOf(self, alleged_ancestor, thing):
    # FIXME: there simply HAS TO BE a better way
    return classOrIdentifier(alleged_ancestor) in self.transitive_objects(classOrIdentifier(thing), RDFS.subClassOf)</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.OntologyAPI.makeEntity"><code class="name flex">
<span>def <span class="ident">makeEntity</span></span>(<span>self, reference, attributes: dict = {}, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and object in this ontology
Objects should only be created using this function (i.e. not by instantiating the OntoObject class directly).
The main reason for this is that the OntoObject does not existence of such object in the current ontology
and thus duplicates could be produced.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>reference</code></strong> :&ensp;<code>URIRef</code> or <code>similar</code></dt>
<dd>URI reference of the object to be created. If the provided reference referres to a class a new object
is instantiated instead of providing reference to an object already existing in the database.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="knowl.databaseAPI.OntoEntity" href="#knowl.databaseAPI.OntoEntity">OntoEntity</a></code></dt>
<dd>A proxy for the entity in the ontology.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeEntity(self, reference, attributes: dict = {}, **kwargs):
    &#34;&#34;&#34;Creates and object in this ontology
    Objects should only be created using this function (i.e. not by instantiating the OntoObject class directly).
    The main reason for this is that the OntoObject does not existence of such object in the current ontology
    and thus duplicates could be produced.

    Parameters
    ----------
    reference : URIRef or similar
        URI reference of the object to be created. If the provided reference referres to a class a new object
        is instantiated instead of providing reference to an object already existing in the database.

    Returns
    -------
    OntoEntity
        A proxy for the entity in the ontology.
    &#34;&#34;&#34;
    refString = reference.n3()
    # merge the attributes
    attributes = {**attributes, **self.__expandPythonAttributes(kwargs)}
    # check if the referenced objects is remembered by the API
    obj = self.getEntity(reference, makeIfDoesNotExist=False)
    if obj is not None:
        # update the objects attributes according to the provided parameters
        obj[attributes.keys()] = attributes.values()
    else:
        # if not, check if it is a class
        if (reference, RDF.type, OWL.Class) in self:
            # if the reference is class, create a new object using that class
            obj = OntoEntity(self, **{**{RDF.type: reference}, **attributes})
        else:
            # This kind of entity creation assumes that the class/type of the entity is specified in the attributes!!!
            obj = OntoEntity(self, name=reference, **attributes)
        self.__objects[refString] = obj
    return obj</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="knowl.database.OntologyDatabase" href="database.html#knowl.database.OntologyDatabase">OntologyDatabase</a></b></code>:
<ul class="hlist">
<li><code><a title="knowl.database.OntologyDatabase.closelink" href="database.html#knowl.database.OntologyDatabase.closelink">closelink</a></code></li>
<li><code><a title="knowl.database.OntologyDatabase.destroy" href="database.html#knowl.database.OntologyDatabase.destroy">destroy</a></code></li>
<li><code><a title="knowl.database.OntologyDatabase.setCredentials" href="database.html#knowl.database.OntologyDatabase.setCredentials">setCredentials</a></code></li>
<li><code><a title="knowl.database.OntologyDatabase.setup" href="database.html#knowl.database.OntologyDatabase.setup">setup</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="knowl.databaseAPI.ProxyAttribute"><code class="flex name class">
<span>class <span class="ident">ProxyAttribute</span></span>
<span>(</span><span>ns, caller)</span>
</code></dt>
<dd>
<div class="desc"><p>This object serves as proxy for OntoEntity's property.
It is a "hack" to make namespace work in the dot notation.
I.e., entity.Namespace.property</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProxyAttribute():
    &#34;&#34;&#34;This object serves as proxy for OntoEntity&#39;s property.
    It is a &#34;hack&#34; to make namespace work in the dot notation.
    I.e., entity.Namespace.property
    &#34;&#34;&#34;

    def __init__(self, ns, caller):
        self._ns = ns
        self._caller = caller

    def __setattr__(self, key, value):
        if key.startswith(&#34;_&#34;):
            super().__setattr__(key, value)
        else:
            self._caller[self._ns[key]] = value

    def __getattr__(self, key):
        if key.startswith(&#34;_&#34;):
            super().__getattribute__(key)
        else:
            return self._caller[self._ns[key]]</code></pre>
</details>
</dd>
<dt id="knowl.databaseAPI.ProxyReference"><code class="flex name class">
<span>class <span class="ident">ProxyReference</span></span>
<span>(</span><span>name, namespace, caller)</span>
</code></dt>
<dd>
<div class="desc"><p>RDF URI Reference: <a href="http://www.w3.org/TR/rdf-concepts/#section-Graph-URIref">http://www.w3.org/TR/rdf-concepts/#section-Graph-URIref</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProxyReference(URIRef):

    def __new__(cls, name, namespace, caller, *args, **kwargs):
        value = namespace[name]
        base = None
        return super().__new__(cls, value, base)

    def __init__(self, name, namespace, caller):
        super().__init__()
        self._ns = namespace
        self._caller = caller

    def __call__(self, **kwargs):
        return self._caller(self, {self._ns[k]: castIntoValidTerm(v) for k, v in kwargs.items()})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>rdflib.term.URIRef</li>
<li>rdflib.term.Identifier</li>
<li>rdflib.term.Node</li>
<li>builtins.str</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="knowl" href="index.html">knowl</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="knowl.databaseAPI.castIntoProperURI" href="#knowl.databaseAPI.castIntoProperURI">castIntoProperURI</a></code></li>
<li><code><a title="knowl.databaseAPI.castIntoValidTerm" href="#knowl.databaseAPI.castIntoValidTerm">castIntoValidTerm</a></code></li>
<li><code><a title="knowl.databaseAPI.isValidURI" href="#knowl.databaseAPI.isValidURI">isValidURI</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="knowl.databaseAPI.OntoEntity" href="#knowl.databaseAPI.OntoEntity">OntoEntity</a></code></h4>
<ul class="two-column">
<li><code><a title="knowl.databaseAPI.OntoEntity.destroy" href="#knowl.databaseAPI.OntoEntity.destroy">destroy</a></code></li>
<li><code><a title="knowl.databaseAPI.OntoEntity.exists" href="#knowl.databaseAPI.OntoEntity.exists">exists</a></code></li>
<li><code><a title="knowl.databaseAPI.OntoEntity.list" href="#knowl.databaseAPI.OntoEntity.list">list</a></code></li>
<li><code><a title="knowl.databaseAPI.OntoEntity.localType" href="#knowl.databaseAPI.OntoEntity.localType">localType</a></code></li>
<li><code><a title="knowl.databaseAPI.OntoEntity.n3" href="#knowl.databaseAPI.OntoEntity.n3">n3</a></code></li>
<li><code><a title="knowl.databaseAPI.OntoEntity.node" href="#knowl.databaseAPI.OntoEntity.node">node</a></code></li>
<li><code><a title="knowl.databaseAPI.OntoEntity.properties" href="#knowl.databaseAPI.OntoEntity.properties">properties</a></code></li>
<li><code><a title="knowl.databaseAPI.OntoEntity.type" href="#knowl.databaseAPI.OntoEntity.type">type</a></code></li>
<li><code><a title="knowl.databaseAPI.OntoEntity.usage" href="#knowl.databaseAPI.OntoEntity.usage">usage</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="knowl.databaseAPI.OntoProperty" href="#knowl.databaseAPI.OntoProperty">OntoProperty</a></code></h4>
</li>
<li>
<h4><code><a title="knowl.databaseAPI.OntologyAPI" href="#knowl.databaseAPI.OntologyAPI">OntologyAPI</a></code></h4>
<ul class="two-column">
<li><code><a title="knowl.databaseAPI.OntologyAPI.baseNS" href="#knowl.databaseAPI.OntologyAPI.baseNS">baseNS</a></code></li>
<li><code><a title="knowl.databaseAPI.OntologyAPI.existEntity" href="#knowl.databaseAPI.OntologyAPI.existEntity">existEntity</a></code></li>
<li><code><a title="knowl.databaseAPI.OntologyAPI.getEntity" href="#knowl.databaseAPI.OntologyAPI.getEntity">getEntity</a></code></li>
<li><code><a title="knowl.databaseAPI.OntologyAPI.getEntsByClass" href="#knowl.databaseAPI.OntologyAPI.getEntsByClass">getEntsByClass</a></code></li>
<li><code><a title="knowl.databaseAPI.OntologyAPI.getProperty" href="#knowl.databaseAPI.OntologyAPI.getProperty">getProperty</a></code></li>
<li><code><a title="knowl.databaseAPI.OntologyAPI.isAncestorOf" href="#knowl.databaseAPI.OntologyAPI.isAncestorOf">isAncestorOf</a></code></li>
<li><code><a title="knowl.databaseAPI.OntologyAPI.makeEntity" href="#knowl.databaseAPI.OntologyAPI.makeEntity">makeEntity</a></code></li>
<li><code><a title="knowl.databaseAPI.OntologyAPI.namespaces" href="#knowl.databaseAPI.OntologyAPI.namespaces">namespaces</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="knowl.databaseAPI.ProxyAttribute" href="#knowl.databaseAPI.ProxyAttribute">ProxyAttribute</a></code></h4>
</li>
<li>
<h4><code><a title="knowl.databaseAPI.ProxyReference" href="#knowl.databaseAPI.ProxyReference">ProxyReference</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>